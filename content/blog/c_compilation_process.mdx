---
title: C++ Compilation Process
description: Using g++ to understand the C++ compilation process
date: 2024-03-04
tags: ["compilers", "c++", "g++"]
published: true
---

Understanding the C compilation process in more depth demystified important concepts for me early on - concepts such as preprocessing, intermediate representation, assemblers, and the linker (static and dynamic). It also helped me with debugging across various languages and environments.

A huge thank you to Mike Shah, who I learned a large part of the following from.

## GNU, GCC, and g++
GNU is a free software project started in 1983 with the goal of creating a Unix-compatible operating system composed entirely of free software. It's a recursive acronym for "GNU's Not Unix".

GCC is the GNU Compiler Collection.

Compilers are typically divided into frontends and backends. Frontends are language-specific, and they generate an intermediate representation of source code that allows the backend to be shared across multiple languages. We'll explore both frontend and backend in detail.

g++ is the frontend we'll be using. g++ will then hand over the intermediate representation to the appropriate backend components from the GNU Compiler Collection.

## Example Files

To understand how object files, header files, and libraries fit into the compilation process, we'll use three example files:

<span className="text-[green] dark:text-[lightgreen]">source.cpp</span> contains an implementation of an `add()` function:
```c++
// source.cpp
int add(int a, int b)
{
        return a + b;
}
```
<span className="text-[green] dark:text-[lightgreen]">header.hpp</span> is a header file containing the <strong><a href="#symbols">symbol</a> for the `add()` function:</strong>:
```c++
// header.hpp
int add(int a, int b);
```
<span className="text-[green] dark:text-[lightgreen]">main.cpp</span> contains the entry point to our program - the `main()` function.
```c++
// main.cpp
#include "header.hpp"
int main()
{
	add(3, 2);
	return 0;
}
```
---

# Frontend

## The Preprocessor
The preprocessor takes our .cpp files as inputs. It processes all of our <span className="text-[#CF9FFF]">#include</span>, <span className="text-[#CF9FFF]">#define</span>, and <span className="text-[#CF9FFF]">#if</span> directives.

We can use the `-E` flag to view the `.i` file that the preprocessor will output: 
```bash
g++ -E main.cpp
```
Output:
```cli
# 0 "main.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "main.cpp"

# 1 "header.hpp" 1

int add(int a, int b);
# 3 "main.cpp" 2
int main(){
 int answer = add(2, 4);
 return 0;
}
```
The line `#include "header.hpp"` from our original `main.cpp` file has been replaced with the actual code from the `header.hpp` file.

We can see above, though, that the definition of `add()` from `source.cpp` is not included in the preprocessor output - `source.cpp` isn't being brought in at all yet.

We need to pass all of the .cpp files in our program to `g++` as arguments. We'll explain why in detail in the <a href="#staticlinking">static linking</a> section, but for now we'll add `source.cpp` as an argument and check the preprocessors output again.

```bash
g++ -E main.cpp source.cpp
```
```cli
# 0 "main.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "main.cpp"

# 1 "header.hpp" 1

int add(int a, int b);
# 3 "main.cpp" 2
int main(){
 int answer = add(2, 4);
 return 0;
}
# 0 "source.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "source.cpp"

int add(int a, int b)
{
 return a + b;
}
```


## Compiler
Takes in .i file.

It can be seen as the bridge between the frontend and backend.
It performs lexical, syntax, and semantic analysis on the preprocessed .i file using trees, before converting the frontend trees to an intermediate representation code (IR) that backend can understand, currently GIMPLE with C and C++ frontends.

The flag `-fdump-tree-gimple` allows us to dump gimple files to our directory.

```bash
g++ -fdump-tree-gimple main.cpp source.cpp
```

a-main.cpp.006t.gimple:
```c
int main ()
{
  int D.2352;

  {
    int answer;

    answer = add (2, 4);
    D.2352 = 0;
    return D.2352;
  }
  D.2352 = 0;
  return D.2352;
}
```
a-source.cpp.006t.gimple:
```c
int add (int a, int b)
{
  int D.2350;

  D.2350 = a + b;
  return D.2350;
}
```

---

# Backend

## Compiler cont'd. - Optimization and Target-Specific Code Generation (hidden from the user)
Optimises the intermediate representation given by the frontend and then gives target specific assembly.
outputs intermediate representation source.s (Intermediate representation)
outputs .s file

## Assembler
Takes in .s
Outputs object files with source.o

## Symbols <span id="symbols"></span>
Explain symbols, and that .o files have symbol tables. These are resolved during linking, which means that order of files in linking matters. This is because the linker needs to have seen undefined symbols and be looking for their implementations in following files.

## Static Linker
Takes in .o files and resolves symbols (names of variables, functions, sections etc) in the .o file's symbol table with actual implementations in other .o files listed in command. Order matters.

As mentioned in the preprocessor section earlier, when we try to actually compile `main.cpp` withouth passing in `source.cpp` like this...

```bash
g++ main.cpp
```

We get an error:

```bash
/usr/bin/ld: /tmp/ccKQGsdB.o: in function `main':
main.cpp:(.text+0x17): undefined reference to `add(int, int)'
collect2: error: ld returned 1 exit status
```

The program `/usr/bin/ld` in the error above is the linker.

Notice that the error says <strong className="text-[brown] dark:text-[bisque]">undefined</strong> reference. The linker knows about `add()` from the <a href="#symbols">symbol</a> in the `header.hpp` file included by the preprocessor, however, there's no <strong className="text-[navy] dark:text-[skyblue]">definition.</strong>

If we remove `#include "header.hpp"` from our `main.cpp` file and run take a look at the preprocessor output again...
```
g++ -E main.cpp
```

## Dynamic Linker
Takes in .o files and links unresolved symbols in .o symbol table with shared (dynamic) libraries on the target system such as Windows .dll (dynamic-link libraries) files.
outputs .exe

